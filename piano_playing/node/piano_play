#!/usr/bin/env python
"""
DESCRIPTION:
+ Moves left arm to locate gun
+ Moves left arm to pick up gun
+ Moves left arm to find target

PUBLSIHERS:
+ display_trajectory_publisher (/move_group/display_planned_path) - displays trajectory in RViz

SUBSCRIBERS:
+ tag_pose_sub (/tag_pose) - subscribes to tag_pose, calls self.aim
+ tag_pose_sub (/start_aiming) - subscribes to start_aiming, calls self.initiate_aiming

ACTION SERVICES:
+ _asgun (guncommander) - Initiates action service for commander node
+ _asaim (aimcommander) - Initiates action service for commander node
"""

from __future__ import division

import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
from moveit_msgs.msg import Grasp
import geometry_msgs.msg
from geometry_msgs.msg import Point, Quaternion, Pose, PoseStamped
import numpy as np
from std_msgs.msg import String, Bool
from moveit_commander.conversions import pose_to_list
import baxter_interface
from baxter_interface import Gripper, CHECK_VERSION
from sensor_msgs.msg import Range
import tf.transformations as tr
from tf.transformations import quaternion_matrix
from tf.transformations import quaternion_from_euler
from tf.transformations import euler_from_matrix
from std_msgs.msg import Bool


import roslib
roslib.load_manifest('terminator')
import actionlib
from std_msgs.msg import Bool

import terminator.msg

# from gripper import *


class PianoPlay(object):
    """ manipulates baxters left arm """

    def __init__(self):

        rospy.loginfo("Initializing Baxter")
        super(PianoPlay, self).__init__()

        joint_state_topic = ['joint_states:=/robot/joint_states']
        moveit_commander.roscpp_initialize(joint_state_topic)

        self.plan_attempts = 3

        #moveit_commander.roscpp_initialize(sys.argv)
        moveit_commander.roscpp_initialize(sys.argv)
        self.robot = moveit_commander.RobotCommander()
        self.scene = moveit_commander.PlanningSceneInterface()

        self.left_group = moveit_commander.MoveGroupCommander("left_arm")

        # Planning and Execution parameters
        self.position_tol = 0.03
        self.orientation_tol = 0.3

        self.left_group.set_goal_position_tolerance(self.position_tol)
        self.left_group.set_goal_orientation_tolerance(self.orientation_tol)
        self.left_group.set_planning_time(10.0)
        self.left_group.allow_replanning(True)
        self.left_group.set_max_velocity_scaling_factor(0.15)
        self.left_group.set_max_acceleration_scaling_factor(0.1)


        # State Gripper (L/R)
        self.left_gripper = Gripper('left', CHECK_VERSION)
        # Reboot Gripper
        self.left_gripper.reboot()
        # Calibrate Gripper
        self.left_gripper.calibrate()
        # Open Gripper

        print("got to the initial pose")
        self.orientation_x = 0.997938
        self.orientation_y = 0.0628973
        self.orientation_z = 0.00953334
        self.orientation_w = -0.00857231

        self.position.x = 0.870284
        self.position.y = 0.345092
        self.position.z = 0.210538
        # ''' test '''
        # test_pose = geometry_msgs.msg.Pose()
        # curr_left_pose = self.left_group.get_current_pose().pose
        # test_pose.orientation_x = 0.997938
        # test_pose.orientation_y = 0.0628973
        # test_pose.orientation_z = 0.00953334
        # test_pose.orientation_w = -0.00857231

        # test_pose.position.x = 0.870284
        # test_pose.position.y = 0.345092
        # test_pose.position.z = 0.210538

        # plan_left_first, fraction_left, plan_success = plan_cartesian_path(curr_left_pose, test_pose, self.left_group)
        # display_trajectory(plan_left_first, self.robot, self.display_trajectory_publisher)

        # self.left_group.execute(plan_left_first, wait=True)
        # self.left_group.stop()
		# self.left_group.clear_pose_targets()


        # size of April tag
        # important for placement of gripper
        self.tag = 0.025
        self.camera_offset = 0.0125

        # Amount to pull back pre and post grip (approach, retreat)
        self.prestandoff = 0.15
        self.poststandoff = 0.2
        # vertical distance from gun to tag
        self.vert_tg = 0.31

        # position adjustment parameters
        self.x_coord = 0.135
        self.y_coord = 0.175
        self.z_coord = 0.01

        self.dy = 0.01
        self.dz = 0.005


        rospy.loginfo("Before display trajectory")
        # trajectory in RVIZ
        self.display_trajectory_publisher = rospy.Publisher(
            '/move_group/display_planned_path',
            moveit_msgs.msg.DisplayTrajectory,
            queue_size=20)

        # # init pose goal for right EE
        # self.init_goal = geometry_msgs.msg.Pose()
        # self.init_goal.orientation.x = 0.065
        # self.init_goal.orientation.y = 0.766
        # self.init_goal.orientation.z = -0.022
        # self.init_goal.orientation.w = 0.639

        # self.init_goal.position.x = 0.415
        # self.init_goal.position.y = 0.6#0.531
        # self.init_goal.position.z = -0.15

        # pose of the tag
        self.tag_pose = None

        self.tag_pose_sub = rospy.Subscriber('/tag_pose', Pose, self.tag_position)

        rospy.loginfo("after getting the pose")

        print("Done Initializing Baxter Left Arm")
        pre_grasp = self.move_gripper(pose_tag, pre_standoff=True)
        rospy.loginfo("move gripper")

    def get_transform(pose):

        quat_list = [pose.orientation.x, pose.orientation.y, pose.orientation.z, pose.orientation.w]

        homo_rot = quaternion_matrix(quat_list)

        T = np.array([[homo_rot[0][0], homo_rot[0][1], homo_rot[0][2], pose.position.x],
                    [homo_rot[1][0], homo_rot[1][1], homo_rot[1][2], pose.position.y],
                    [homo_rot[2][0], homo_rot[2][1], homo_rot[2][2], pose.position.z],
                    [0,              0,              0,              1]])

        return T

    def extract_pose(T):
    # extract euler angles
        rot = np.array([[T[0][0], T[0][1], T[0][2]],
                        [T[1][0], T[1][1], T[1][2]],
                        [T[2][0], T[2][1], T[2][2]]])


        ax, ay, az = euler_from_matrix(rot)
        quat = quaternion_from_euler(ax, ay, az)

        trans = np.array([T[0][3], T[1][3], T[2][3]])

        return quat, trans

    def plan_cartesian_path(EE_pose, goal, move_group):


        print("Terminator Planning Trajectory")

        plan_attempts = 3
        iter = 10
        waypoints = []

        xiter = np.linspace(EE_pose.position.x, goal.position.x, iter)
        yiter = np.linspace(EE_pose.position.y, goal.position.y, iter)
        ziter = np.linspace(EE_pose.position.z, goal.position.z, iter)

        for i in range(iter):
            p = copy.deepcopy(EE_pose)
            p.position.x = xiter[i]
            p.position.y = yiter[i]
            p.position.z = ziter[i]

            # last waypoint use pose of goal
            if i == iter - 1:

                p = copy.deepcopy(goal)
                p.position.x = xiter[i]
                p.position.y = yiter[i]
                p.position.z = ziter[i]

            waypoints.append(p)

        #self.left_group.set_max_velocity_scaling_factor(0.1)
        #self.left_group.set_max_acceleration_scaling_factor(0.1)

        plan_success = True
        fraction = 0.0
        #plan, fraction = move_group.compute_cartesian_path(waypoints, 0.01, 0.0)

        ctr = 0

        while fraction < 0.8:
            plan, fraction = move_group.compute_cartesian_path(waypoints, 0.01, 0.0)

            if ctr == plan_attempts:
                plan_success = False
                break

            ctr += 1

        #self.left_group.set_max_velocity_scaling_factor(0.6)
        #self.left_group.set_max_acceleration_scaling_factor(0.6)

        return plan, fraction, plan_success

def made_it(goal, actual, position_tol, orientation_tol):


        goal = pose_to_list(goal)
        actual = pose_to_list(actual)

        pos_goal = True
        orient_goal = True

        # check if final position is within tolerance
        for index in range(3):
            if abs(actual[index] - goal[index]) > position_tol:
                pos_goal = False

        # check if final orientation is within tolerance
        for index in range(3, 6):
            if abs(actual[index] - goal[index]) > orientation_tol:
                orient_goal = False

        if pos_goal and orient_goal:
            print("Goal Reached")
            return True

        print("Goal Not Reached!")
        return False

def display_trajectory(plan, robot, display_trajectory_publisher):

    display_traj = moveit_msgs.msg.DisplayTrajectory()
    display_traj.trajectory_start = robot.get_current_state()
    display_traj.trajectory.append(plan)
    display_trajectory_publisher.publish(display_traj)


def move_arm(EE_pose, pose_goal, move_group, robot, display_trajectory_publisher):
    """ Attempts to move the arm in a cartesian path using waypoints if the plan
    to follow tha path fails a target pose goal will be set and the path planning
    component is aborted.

    Args:
        EE_pose (Pose): pose of the end effector
        goal (Pose): pose of the goal configuration
        move_group: move group commander
        robot: moveit robot commander
        display_trajectory_publisher: rviz publisher
    """

    plan, fraction, plan_success = plan_cartesian_path(EE_pose, pose_goal, move_group)

    print("The fraction of path covered")
    print(fraction)

    if plan_success:
        # display plan in rviz
        print("Using cartesian path")
        display_trajectory(plan, robot, display_trajectory_publisher)
        rospy.sleep(2)

        print("============ Press `Enter` to move gripper ============")
        raw_input()

        try:
            # execute path
            move_group.execute(plan, wait=True)
            move_group.stop()
            move_group.clear_pose_targets()

            # wait for baxter to get to goal
            rospy.sleep(2)

        except (rospy.ServiceException, rospy.ROSException), e:
            rospy.loginfo("Service call failed: %s" % (e,))

    else:
        print("Using pose goal")
        print("============ Press `Enter` to move gripper ============")
        raw_input()

        try:
            move_group.set_pose_target(pose_goal)
            plan = move_group.go(wait=True)
            move_group.stop()
            move_group.clear_pose_targets()

        except (rospy.ServiceException, rospy.ROSException), e:
            rospy.loginfo("Service call failed: %s" % (e,))

    
    def tag_position(self, msg):
        """ callback for april tag position

        Args:
            msg (Pose): pose of the april tag
        """

        self.tag_pose = msg
        print(tag_pose)


    # def pick_up_gun(self, pose_tag):
    #     """ callback function for Subscriber to /tag_pose

    #     The trajectory is divided into five stages

    #     1) move gripper to standoff location
    #     2) move gripper to handle
    #     3) grasp the gun
    #     4) pick up gun vertically to standoff location
    #     5) go the aiming position

    #     Args:
    #         pose_tag (Pose): pose of the april tag
    #     """

    #     # stage 1
    #     print("============ Move to gun ============")
    #     rospy.sleep(2)
    #     pre_grasp = self.gggggg   m m mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm[                                                                 (pose_tag, pre_standoff=True)

    #     # stage 2
    #     print("============ Move to gun handle ============")
    #     grasp_handle = self.move_gripper(pose_tag, grasp=True)

    #     # stage 3
    #     if pre_grasp and grasp_handle:
    #         print("============ Press `Enter` to close left gripper ============")
    #         #raw_input()
    #         self.left_gripper.close()
    #         rospy.sleep(2)

    #     # stage 4
    #     print("============ Lift gun off Table ============")
    #     post_grasp = self.move_gripper(pose_tag, post_standoff=True)


    #     # stage 5
    #     print("============ Moving too Aiming Pose  ============")
    #     aiming_placed = self.move_gripper(pose_tag, aiming=True)

    #     if post_grasp and aiming_placed:
    #         # made it this far it is a success
    #         return True

    #     return False

    def move_gripper(self, pose_tag, pre_standoff=False, post_standoff=False, grasp=False, aiming=False):
        """ moves gripper to a goal pose

        Args:
            pose_tag (Pose): pose of the april tag

        Returns:
            success (bool): True gripper makes it to pre-grasp standoff pose
        """

        # get pose of EE
        left_EE_pose = self.left_group.get_current_pose().pose
        print("left ee pose is")
        print(left_EE_pose)
        # compute transformation of gun relative to EE
        Teg = get_transform(pose_tag)

        Tbe = get_transform(left_EE_pose)
        # tranformation from baxter to gun
        Tbg = np.dot(Tbe, Teg)

        # pose of gun relative to baxter
        quat, trans = extract_pose(Tbg)

        print("pose of tag")
        print(trans)
        print(quat)

        # move EE right behind gun and stop
        pose_goal = geometry_msgs.msg.Pose()

        if pre_standoff:
            print("pre-standoff")
            pose_goal.position.x = trans[0] - self.prestandoff
            pose_goal.position.y = trans[1] + self.y_coord    #+ self.tag + self.camera_offset + self.y_coord
            pose_goal.position.z = trans[2] + self.vert_tg


        elif post_standoff:
            print("post-standoff")
            # lift gun off table vertically
            pose_goal.position.x = left_EE_pose.position.x
            pose_goal.position.y = left_EE_pose.position.y
            pose_goal.position.z = left_EE_pose.position.z + self.poststandoff


        elif grasp:
            print("grasp")
            # move to grasp pose
            pose_goal.position.x = left_EE_pose.position.x + self.x_coord
            pose_goal.position.y = left_EE_pose.position.y #+ self.dy
            pose_goal.position.z = left_EE_pose.position.z + self.dz

        # attempt to move left arm to goal
        move_arm(left_EE_pose, pose_goal, self.left_group, self.robot, self.display_trajectory_publisher)


        # wait for baxter to get to goal
        rospy.sleep(2)

        # test if made it to pre-pick up position
        left_EE_pose = self.left_group.get_current_pose().pose

        print("EE pose")
        print(left_EE_pose)

        # check if orientation and position of goal are met
        return made_it(pose_goal, left_EE_pose, self.position_tol, self.orientation_tol)

def main():

    rospy.init_node("piano_play", anonymous=True)

    try:
        move = PianoPlay()
    except rospy.ROSInterruptException:
        return
    except KeyboardInterrupt:
        return

    rospy.spin()


if __name__ == '__main__':
    main()












#